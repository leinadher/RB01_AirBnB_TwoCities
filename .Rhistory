c(1:18)*10
# EXERCISE 2.1
seq(0, 10, 1)
seq(0, 10, .83)
seq(0, 10, .835)
seq(0, 10, length.out=13)
round(seq(0, 10, length.out=13), 2)
# EXERCISE 1.1
2*10 + 4/(3 + 1)
seq(0, 10, 2)
c(10,20,10) * c(0,1,2)
# 0 20 20
# 0 20 20
1:10 * 3
# 3 6 9 12 15 18 21 24 27 30
c(1,2,100) / c(1,4,0)
# 1 0.5 Inf
c(1,2,100) + c(1:6)
# 2 4 103 5 7 106
c(1,2,100) + c(1:7)
# 2 4 103 5 7 106 8
c("A", "B", "C") + 2
# ERROR
c("1", "2", "3") + 2
# EXERCISE 2.4
letters[1:12]
# "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l"
0 / 0
# NaN (Not a Number)
c(TRUE, true, FALSE, FALSE)
# Error: object 'true' not found
c(TRUE, FALSE, TRUE, TRUE) + 1
# c(1, 0, 1, 1) + 1 = 2 1 2 2
c(T, FALSE, TRUE)
# 1. the very first element
seq.1[1]
# EXERCISE 2.4
seq.1 <- c(1,2,3, 1,2,3, 1,2,3)
# 1. the very first element
seq.1[1]
# 3. the 3 central elements
seq.1[4:6]
# 4. all those elements that are equal or greater than 2
seq.1 => 2
# 4. all those elements that are equal or greater than 2
seq.1 >= 2
# 4. all those elements that are equal or greater than 2
seq.1[seq.1 >= 2]
# SESSION 01
# EXERCISE 1.1
2*10 + 4/(3 + 1)
2*(37-3**3)
sqrt(16) + (10 + 3)
2**4 + (1*3)/(2+3)
3 + ((27)**(1/3) -8)
1/(2**3 - 8)
radius <- 10
area <- radius**2 * pi
area
# EXERCISE 1.2
results.a <- 2*10 + 4/(3 + 1)
results.b <- 2*(37-3**3)
results.c <- sqrt(16) + (10 + 3)
results.a * results.b / (results.c + results.a^2)
# EXERCISE 1.3
results.a <- 1
results_1 <- 1
results.computation.done.in.a <- 1
A.res <- 1
A_.res <- 1
A <- 1
TRUE.FALSE <- 1
mean <- 1
iris <- 1
# EXERCISE 2.1
c(2, 10, 13)
c(10:15)
c(1:18)*10
# EXERCISE 2.2
seq(0, 10, 1)
seq(0, 10, 2)
round(seq(0, 10, length.out=13), 2)
# EXERCISE 2.3
c(10,20,10) * c(0,1,2)
# 0 20 20
1:10 * 3
# 3 6 9 12 15 18 21 24 27 30
c(1,2,100) / c(1,4,0)
# 1 0.5 Inf
c(1,2,100) + c(1:6)
# 2 4 103 5 7 106
c(1,2,100) + c(1:7)
# 2 4 103 5 7 106 8
c("A", "B", "C") + 2
Mat_1 <- matrix(data = 0:5, ncol = 3)
Mat_1
Mat_2 <- matrix(data = 0:15, ncol = 3)
Mat_2
Mat_1 <- matrix(data = 0:5, ncol = 3)
Mat_1
Mat_2 <- matrix(data = 10:15, ncol = 3)
Mat_2
Mat_1 + Mat_2
Mat_1[1, 2]
Mat_1 <- matrix(data = 0:5, ncol = 3)
Mat_2[ , 2]
c("Ten", 10, 20)
seq(6:1)
-seq(6:1)
mat_2 <- matrix(data = 6:1, nrow = 2, ncol = 3)
Mat_3 <- matrix(data = 6:1, nrow = 2, ncol = 3)
Mat_3
rbind(c(6, 4, 2), c(5, 3, 1))
cbind(1:2, 3:4, 5:6)
cbind(6:5, 4:3, 2:1)
# 3 ways to create same matrix:
matrix(data = 6:1, nrow = 2, ncol = 3)
rbind(c(6, 4, 2), c(5, 3, 1))
cbind(6:5, 4:3, 2:1)
cbind(Mat_1, c(1, 2, 3))
Mat_1 <- matrix(data = 0:5, ncol = 3)
Mat_1
Mat_2 <- matrix(data = 10:15, ncol = 3)
Mat_2
Mat_1 + Mat_2
Mat_1[1, 2]
Mat_2[ , 2]
# All elements in a vector are of a same type:
c("Ten", 10, 20)
[1] "Ten" "10"  "20"
Mat_1 <- matrix(data = 0:5, ncol = 3)
Mat_1
Mat_2 <- matrix(data = 10:15, ncol = 3)
Mat_2
Mat_1 + Mat_2
Mat_1[1, 2]
Mat_2[ , 2]
# All elements in a vector are of a same type:
c("Ten", 10, 20)
# "Ten" "10"  "20"
# 3 ways to create same matrix:
matrix(data = 6:1, nrow = 2, ncol = 3)
rbind(c(6, 4, 2), c(5, 3, 1))
cbind(6:5, 4:3, 2:1)
rbind(Mat_1, c(1, 2, 3))
Mat_1 <- matrix(data = 0:5, ncol = 3)
Mat_1
Mat_2 <- matrix(data = 10:15, ncol = 3)
Mat_2
Mat_1 + Mat_2
Mat_1[1, 2]
Mat_2[ , 2]
# All elements in a vector are of a same type:
c("Ten", 10, 20)
# "Ten" "10"  "20"
# 3 ways to create same matrix:
matrix(data = 6:1, nrow = 2, ncol = 3)
rbind(c(6, 4, 2), c(5, 3, 1))
cbind(6:5, 4:3, 2:1)
rbind(Mat_1, c(1, 2, 3))
Mat_1[-1, ]
Mat_1[ , -c(2, 3)]
Mat_2 <- matrix(data = 10:15, ncol = 3)
rbind(Mat_1, c(1, 2, 3))
Mat_1[-1, ]
Mat_1[ , -c(2, 3)]
Mat_1 <- matrix(data = 10:15, ncol = 3)
rbind(Mat_1, c(1, 2, 3))
Mat_1[-1, ]
Mat_1[ , -c(2, 3)]
Mat_1 <- matrix(data = 10:15, ncol = 3)
rbind(Mat_1, c(1, 2, 3))
Mat_1[-1]
Mat_1 <- matrix(data = 10:15, ncol = 3)
rbind(Mat_1, c(1, 2, 3))
Mat_1[-1, ]
Mat_1 <- matrix(data = 10:15, ncol = 3)
Mat_1 <- rbind(Mat_1, c(1, 2, 3))
Mat_1[-1, ]
Mat_1[ , -c(2, 3)]
# 01.02.2024
setwd("~/GitHub/RB01_AirBnB_TwoCities")
library(tidyverse)
library(ggthemes)
library(plotly)
library(RColorBrewer)
library(httr)
library(jsonlite)
library(stringr)
library(corrplot)
library(reshape2)
library(readxl)
# For maps:
library(sf)
library(ggmap)
library(leaflet)
library(osmdata)
library(maptiles)    ## for get_tiles() / used instead of OpenStreetMap
library(tidyterra)   ## for geom_spatraster_rgb() - Background tiles
################################################################################
# LOADING CITY AIRBNB DATA
# Read listings.csv files from folder with city name, and save as data frame
# Loading 'listings.csv' files from all city folders:
file_paths <- list.files(pattern = "listings.csv$",
recursive = TRUE,
full.names = TRUE)
for (file_path in file_paths) {
# Extract city name from the file path
city_name <- sub(".*/(\\w+)/listings.csv", "\\1", file_path, perl = TRUE)
# Read CSV file and assign it to a variable with the city name
assign(city_name, read.csv(file_path))
}
################################################################################
# API CALL AND DATA MERGE
# 1. We obtain demographics data (2023_pad_mdbas_sexe.csv) via API
# 2. We merge listings.csv with demographics data
# API endpoint
api_url <- "https://opendata-ajuntament.barcelona.cat/data/api/action/datastore_search?resource_id=d0e4ec78-e274-4300-a3bc-cb85cf79014d&limit=3000"
# Sending a GET request to the API and check for success
response <- GET(api_url) %>% stop_for_status()
# Extracting content from the response
data <- fromJSON(content(response, "text"), flatten = TRUE)
# The actual data is usually in a specific part of the JSON
# Adjust the following line according to the structure of the JSON response
demographics <- data$result$records[c("Nom_Districte", "Nom_Barri", "Valor")]
# Viewing the first few rows of the dataframe
head(demographics)
# Group by neighborhood, convert 'Valor' to numeric, and sum values
demographics_grouped <- demographics %>%
group_by(Nom_Barri) %>%
mutate(Valor = as.numeric(Valor)) %>%  # Convert 'Valor' column to numeric
summarise(Total_Population = sum(Valor))
# Merge the datasets
Barcelona_md <- left_join(Barcelona, demographics_grouped, by =
c("neighbourhood" = "Nom_Barri"))
################################################################################
# EXTRACT STAR-RATING FROM NAME, AND ADD AS COLUMN TO DATA FRAME
extract_star_rating <- function(name) {
matches <- str_extract(name, "★([0-9.]+)")
as.numeric(gsub("★", "", matches))
}
Barcelona_md$star_rating <- sapply(Barcelona_md$name, extract_star_rating)
head(Barcelona_md[c("name", "star_rating")], 5)
################################################################################
# EXTRACT LICENSE STATUS
# Save to a new column 'LicenseGrouping'
Barcelona_md <- Barcelona_md %>%
mutate(LicenseGrouping = case_when(
grepl("Exempt", license, ignore.case = TRUE) ~ "Exempt",
license != "" & !is.na(license) ~ "License is displayed",
TRUE ~ "License is not displayed"
))
print(Barcelona_md)
################################################################################
# GROUP LARGE TENANTS AND SMALL TENANTS
Barcelona_md <- Barcelona_md %>%
mutate(TenantSizeGrouping = case_when(
calculated_host_listings_count >= 10 ~ "Large tenant",
calculated_host_listings_count <= 9 ~ "Small tenant",
TRUE ~ NA_character_ # This handles any unexpected cases, such as missing values
))
# View the first few rows of the transformed dataset to verify the changes
head(Barcelona_md)
################################################################################
# PLOT1: FREQUENCY OF EACH ROOM TYPE
# Summarize the data to count the number of each property type
property_counts <- Barcelona_md %>%
group_by(room_type) %>%
summarise(quantity = n())
# Create the bar plot
ggplot(property_counts,
aes(x = reorder(room_type, quantity),
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
geom_text(aes(label = quantity),
hjust = 0,
color = "black",
size = 3) +
labs(x = "Room Type",
y = "Count",
title = "Count of each room type",
subtitle = "Barcelona") +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
################################################################################
# PLOT2: CORRELATION PLOT
numeric_data <- Barcelona_md[, sapply(Barcelona_md, is.numeric)]
numeric_data <- numeric_data[, !colnames(numeric_data) %in% c('id',
'latitude',
'longitude',
'number_of_reviews_ltm')]
cor_matrix <- cor(numeric_data, use = "pairwise.complete.obs")
corrplot(cor_matrix, type = "full", tl.col = "black",
title = "Correlation of Numerical Values",
subtitle = "Barcelona",
tl.srt = 45, # Rotate text labels 45 degrees
mar = c(0, 0, 2, 0), # Adjust margins to make room for rotated labels
tl.cex = 0.8, # Adjust text label size
pch = 15) # Use full squares (ASCII 15)
knitr::opts_chunk$set(echo = TRUE)
ggplot(cor_df, aes(Var1, Var2)) +
geom_point(aes(fill = Correlation), size = 12, shape = 21, color = NA) +
scale_size_continuous(guide = "none") +  # Remove size legend
scale_fill_gradient(low = "white", high = "#f1796f") +
labs(title = "Correlation of Numerical Values",
subtitle = "Barcelona",
x = "",
y = "") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
plot.margin = unit(c(0, 0, 2, 0), "lines"))
