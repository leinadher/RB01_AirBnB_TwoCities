" # close quote for modelString
model <- stan_model(model_code=modelString)
N = 20
z = 16
y = c(rep(1,z),rep(0,N-z))
stanFit = sampling( object=model , data=list( y = y , N = N ) , chains=3 , iter=1000 , warmup=100)
params = rstan::extract(stanFit)
dens <- density(params$theta)
plot(dens,main="Posterior",col="darkseagreen", xlim=c(0,1), TeX("$\\theta$"))
max_dens <- max(dens$y)
#lines(c(hdi(params$theta)[2],hdi(params$theta)[3]),c(.1*max_dens,.1*max_dens))
x <- seq(0,1,.001)
y <- dbeta(x,5+z,N-z+2)
lines(x,y,col="orange")
library(rstan)
library(bayestestR)
library(latex2exp)
rstan_options(auto_write = TRUE)
modelString = "
data{
int<lower=0> N ;
int y[N] ; // y is a length-N vector of integers
}
parameters {
real<lower=0,upper=1> theta ;
}
model {
theta ~ beta(5,2) ;
y ~ bernoulli(theta) ;
}
" # close quote for modelString
model <- stan_model(model_code=modelString)
N = 20
z = 16
y = c(rep(1,z),rep(0,N-z))
stanFit = sampling( object=model , data=list( y = y , N = N ) , chains=3 , iter=1000 , warmup=100)
params = rstan::extract(stanFit)
dens <- density(params$theta)
plot(dens,main="Posterior",col="darkseagreen", xlim=c(0,1), TeX("$\\theta$"))
max_dens <- max(dens$y)
#lines(c(hdi(params$theta)[2],hdi(params$theta)[3]),c(.1*max_dens,.1*max_dens))
x <- seq(0,1,.001)
y <- dbeta(x,5+z,N-z+2)
lines(x,y,col="orange")
library(rstan)
library(bayestestR)
library(latex2exp)
rstan_options(auto_write = TRUE)
modelString = "
data{
int<lower=0> N ;
int y[N] ; // y is a length-N vector of integers
}
parameters {
real<lower=0,upper=1> theta ;
}
model {
theta ~ beta(5,2) ;
y ~ bernoulli(theta) ;
}
" # close quote for modelString
model <- stan_model(model_code=modelString)
N = 20
z = 16
y = c(rep(1,z),rep(0,N-z))
stanFit = sampling( object=model , data=list( y = y , N = N ) , chains=3 , iter=100 , warmup=100)
params = rstan::extract(stanFit)
dens <- density(params$theta)
library(rstan)
library(bayestestR)
library(latex2exp)
rstan_options(auto_write = TRUE)
modelString = "
data{
int<lower=0> N ;
int y[N] ; // y is a length-N vector of integers
}
parameters {
real<lower=0,upper=1> theta ;
}
model {
theta ~ beta(5,2) ;
y ~ bernoulli(theta) ;
}
" # close quote for modelString
model <- stan_model(model_code=modelString)
N = 20
z = 16
y = c(rep(1,z),rep(0,N-z))
stanFit = sampling( object=model , data=list( y = y , N = N ) , chains=3 , iter=1000 , warmup=100)
params = rstan::extract(stanFit)
dens <- density(params$theta)
plot(dens,main="Posterior",col="darkseagreen", xlim=c(0,1), TeX("$\\theta$"))
max_dens <- max(dens$y)
#lines(c(hdi(params$theta)[2],hdi(params$theta)[3]),c(.1*max_dens,.1*max_dens))
x <- seq(0,1,.001)
y <- dbeta(x,5+z,N-z+2)
lines(x,y,col="orange")
library(rstan)
## Loading required package: StanHeaders
##
## rstan version 2.26.22 (Stan version 2.26.1)
## For execution on a local, multicore CPU with excess RAM we recommend calling
## options(mc.cores = parallel::detectCores()).
## To avoid recompilation of unchanged Stan programs, we recommend calling
## rstan_options(auto_write = TRUE)
## For within-chain threading using ‘reduce_sum()‘ or ‘map_rect()‘ Stan functions,
## change ‘threads_per_chain‘ option:
## rstan_options(threads_per_chain = 1)
library(bayestestR)
library(latex2exp)
rstan_options(auto_write = TRUE)
plot_posterior <- function(params, Rope = c(.4,.5)){
dens <- density(params$theta)
max_dens <- max(dens$y)
hdi_l <- as.numeric(hdi(params$theta)[2])
hdi_r <- as.numeric(hdi(params$theta)[3])
plot(dens,main="Posterior",col="darkseagreen", TeX("$\\theta$"))
lines(c(hdi_l,hdi_r),c(.12*max_dens,.12*max_dens),col="orange")
text(hdi_l,.15*max_dens,round(hdi_l,3),cex=.6)
text(hdi_r,.15*max_dens,round(hdi_r,3),cex=.6)
text((hdi_l+hdi_r)/2,.15*max_dens,"95% HDI",cex=.6,col="orange")
lines(c(Rope[1],Rope[2]),c(.08*max_dens,.08*max_dens),col="blue")
text(Rope[1],.05*max_dens,Rope[1],cex=.6)
text(Rope[2],.05*max_dens,Rope[2],cex=.6)
text((Rope[1]+Rope[2])/2,.05*max_dens,"ROPE",cex=.6, col="blue")
}
modelString = "
data{
int<lower=0> N ;
int y[N] ; // y is a length-N vector of integers
}
parameters {
real<lower=0,upper=1> theta ;
}
model {
theta ~ beta(2,4) ;
y ~ bernoulli(theta) ;
}
" # close quote for modelString
model <- stan_model(model_code=modelString)
N = 50
z = 10
y = c(rep(1,z),rep(0,N-z))
stanFit = sampling( object=model, data=list(y = y, N = N), iter=2000, warmup=200)
params = rstan::extract(stanFit)
plot_posterior(params, Rope=c(.6,.8))
library(rstan)
## Loading required package: StanHeaders
##
## rstan version 2.26.22 (Stan version 2.26.1)
## For execution on a local, multicore CPU with excess RAM we recommend calling
## options(mc.cores = parallel::detectCores()).
## To avoid recompilation of unchanged Stan programs, we recommend calling
## rstan_options(auto_write = TRUE)
## For within-chain threading using ‘reduce_sum()‘ or ‘map_rect()‘ Stan functions,
## change ‘threads_per_chain‘ option:
## rstan_options(threads_per_chain = 1)
library(bayestestR)
library(latex2exp)
rstan_options(auto_write = TRUE)
plot_posterior <- function(params, Rope = c(.4,.5)){
dens <- density(params$theta)
max_dens <- max(dens$y)
hdi_l <- as.numeric(hdi(params$theta)[2])
hdi_r <- as.numeric(hdi(params$theta)[3])
plot(dens,main="Posterior",col="darkseagreen", TeX("$\\theta$"))
lines(c(hdi_l,hdi_r),c(.12*max_dens,.12*max_dens),col="orange")
text(hdi_l,.15*max_dens,round(hdi_l,3),cex=.6)
text(hdi_r,.15*max_dens,round(hdi_r,3),cex=.6)
text((hdi_l+hdi_r)/2,.15*max_dens,"95% HDI",cex=.6,col="orange")
lines(c(Rope[1],Rope[2]),c(.08*max_dens,.08*max_dens),col="blue")
text(Rope[1],.05*max_dens,Rope[1],cex=.6)
text(Rope[2],.05*max_dens,Rope[2],cex=.6)
text((Rope[1]+Rope[2])/2,.05*max_dens,"ROPE",cex=.6, col="blue")
}
modelString = "
data{
int<lower=0> N ;
int y[N] ; // y is a length-N vector of integers
}
parameters {
real<lower=0,upper=1> theta ;
}
model {
theta ~ beta(2,4) ;
y ~ bernoulli(theta) ;
}
" # close quote for modelString
model <- stan_model(model_code=modelString)
N = 50
z = 10
y = c(rep(1,z),rep(0,N-z))
stanFit = sampling( object=model, data=list(y = y, N = N), iter=2000, warmup=200)
params = rstan::extract(stanFit)
plot_posterior(params, Rope=c(.6,.8))
modelString = "
data{
int<lower=0> N ;
int y[N] ; // y is a length-N vector of integers
}
parameters {
real<lower=0,upper=1> theta ;
model {
theta ~ beta(300.4,699.6) ;
y ~ bernoulli(theta) ;
}
" # close quote for modelString
model <- stan_model(model_code=modelString)
# seq(a,b) creates a sequence of numbers, from a to b. a is 1 by default when not indicated
# additionally, seq(a,b,c) will use c as the step value
seq(1,5)
seq(1,5,0.5)
# this nomenclature is better:
seq(from = 3, to = 10, length.out = 10, by = 2)
# seq(a,b) creates a sequence of numbers, from a to b. a is 1 by default when not indicated
# additionally, seq(a,b,c) will use c as the step value
seq(1,5)
seq(1,5,0.5)
# this nomenclature is better:
seq(from = 3, to = 10, length.out = 10, by = 2)
d_fuel <- read.table(file = "d.fuel.dat" ,header = T, sep = ",")[, -1]
library(plotrix)
n <- 1000
x <- runif(n, min = -1, max = 1)
y <- runif(n, min = -1, max = 1)
r_squ <- x^2 + y^2
plot(x,y,
col = ifelse(r_squ < 1,"darkseagreen3", "black"),
asp = 1,
pch = 19,
xlim=c(-1.000,1.0000))
lines(c(-1,-1,1,1,-1),c(-1,1,1,-1,-1))
draw.circle(0,0,1)
cat("Approximation of Pi:", sum(r_squ < 1) / n * 4)
## Approximation of Pi: 3.128
n <- 100
x <- runif(n, min = -1, max = 1) # runif is r uniform, a uniform random value between -1 and 1
y <- runif(n, min = -1, max = 1)
r_squ <- x^2 + y^2
pi <- 4* sum(r_squ < 1) / n
pi
## [1] 3.112
# We create one vector for the heights of winners and one for opponents
winner <- c(183, 191, 185, 185, 182, 182, 188, 188, 188, 185, 185, 177,
182, 182, 193, 183, 179, 179, 175)
opponent <- c(191, 165, 187, 175, 193, 185, 187, 188, 173, 180, 177, 183,
185, 180, 180, 182, 178, 178, 173)
# Determine the length of each vector:
length(winner)
length(opponent)
# Index elements within the vectors:
winner[c(6:10)]
# Determine specific indexes:
winner[3]
winner[5]
winner[10]
winner[12]
# Change entry for Bill CLinton, then print:
winner[7] <- 189
winner[8] <- 189
winner
# Check means of both vectors:
mean(winner)
mean(opponent)
# Check average height differences, median average difference:
mad(winner)
mad(opponent)
# Variance s^2:
var(winner)
var(opponent)
# Standard deviation
# Note:standard deviation is expressed in same units, cm
sd(winner)
sd(opponent)
# Determine values using definitions; variance s^2:
#s^2 = (xn - mean(x))^2 / (len(winner)-1)
var(winner)
var_winner <- sum((winner - mean(winner))^2) / (length(winner)-1)
var_winner
mad(winner)
mad(opponent)
# Alter values in grades so that median is the same, but mean decreases
grades <- c(4.2, 2.3, 5.6, 4.5, 4.8, 3.9, 5.9, 2.4, 5.9, 6, 4, 3.7, 5, 5.2, 4.5, 3.6, 5, 6, 2.8, 3.3, 5.5, 4.2, 4.9, 5.1)
# If we calculate length of grades, we'll find the number is even:
length(grades)
sorted_grades <- sort(grades)
sorted_grades
# Therefore, the median will be between these 2 central values:
sorted_grades[c(12:13)]
# Calculate median and mean:
median(grades)
mean(grades)
# To not alter the median, we may replace all values from 1 to 11 to the smallest value possible:
grades_adjusted <- sorted_grades
grades_adjusted[c(1:11)] <- 1
grades_adjusted
median(grades_adjusted)
mean(grades_adjusted)
# BOXPLOT
boxplot(grades,
grades_adjusted,
main = "Boxplot",
col = c("orange", "lightblue")
)
# The resulting boxplot proves that the median remains the same, while the box has grown due to more extreme lower values. The upper quartile stays the same.
library(MASS)
plot(lstat, mevd)
# We load the MASS library, and load the Boston dataset:
library(MASS)
# We get a linear regression model using least squares: lm(y ~ x1 + x2 + x3)
# summary() function will output the regression coefficients for all predictors
# a) Multiple linear regression model with DV: medv, IV: lstat, age
fit <- lm(medv ~ lstat + age)
library(MASS)
plot(lstat, mevd, data = Boston)
head(Boston)
plot(Boston$age, Boston$medv)
abline(lm(Boston$medv ~ Boston$age), col="red")
fit <- lm(Boston$medv ~ Boston$age)
summary(fit)
boxplot(Boston$age, col="red")
a.1 <- 10
a.2 <- 3 * a.1
a.2
## overwriting is irreversible
a.2 <- 0
a.2
## incomplete statements (note the "plus" symbol)
2 + 4 *
(3 + 4)
## interrupting a statement (note selection)
2 + 4 *
(3 + 4)
2 + 4 *
7
## objects only exist once they were created in R
a.3 <- 17
meric vectors
## creating numeric vectors
c(2,3,15)
c(2:5)
c("Jane")
c/Jane
c(Jane)
c("Jane", "Rpdr")
c("Agatha", "Koch")
if a.1 <= a.2:
a = 2
a
vector.1 <= 20
vector.1 <- c(1, 2 ,45, 20, 123, 10, 20)
vector.1 <= 20
c(1000, 1000, 1000) + 1:6
c(10, 20, 30) + 1:6
vector.1[1]
vector.1[c(2,3,5)]
## logical operators
v.1
v.1 > 18
v.1 < 18
## creating numeric vectors
c(2,3,15)
v.1 <- c(15,23,55,10,19)
v.2 <- c(1,2,10, 10^2,      1) ## empty spaces do not matter (but not elegant)
v.3 <- c(1.1, 2.3, 7)
## alternative to c()
1:12 ## sequences can be created via ":"
## string vectors
c("Tana", "John", "Monday", "John Doe") ## strings can contain empty spaces
## logical vectors
c(TRUE, FALSE, TRUE, FALSE)
## logical operators
v.1
v.1 > 18
v.1 < 18
v.1 >= 19
v.1 <= 23
v.1 == 19
v.1 != 19
## combining logical vectors (going further)
v.4 <- 1:10
v.4
v.4 > 5
v.1[c(TRUE, FALSE, FALSE, TRUE)]
v.1[2]
v.1[c(2:4)]
v.1[c(TRUE,FALSE,FALSE,FALSE,TRUE)] ## first and last elements
## elements can be dropped
v.1[-1]
c(10, 20, 30)
A <- c(10, 20, 30)
B <- c(1, 2, 3, 4)
A*B
A == 2 |B == 3
A == 2
B == 3
A - B
# 30.01.2024
setwd("~/GitHub/RB01_AirBnB_TwoCities")
library(ggplot2)
library(ggthemes)
library(tidyr)
library(dplyr)
library(plotly)
library(RColorBrewer) # For loading special colour palettes
# Loading 'listings.csv' files from all city folders:
file_paths <- list.files(pattern = "listings.csv$",
recursive = TRUE,
full.names = TRUE)
for (file_path in file_paths) {
# Extract city name from the file path
city_name <- sub(".*/(\\w+)/listings.csv", "\\1", file_path, perl = TRUE)
# Read CSV file and assign it to a variable with the city name
assign(city_name, read.csv(file_path))
}
################################################################################
# Structure of data:
str(Barcelona)
str(Zurich)
# Price means
mean(Barcelona$price, na.rm = TRUE)
mean(Zurich$price, na.rm = TRUE)
# Number of reviews means
mean(Barcelona$number_of_reviews, na.rm = TRUE)
mean(Zurich$number_of_reviews, na.rm = TRUE)
# Number of reviews medians
median(Barcelona$number_of_reviews, na.rm = TRUE)
median(Zurich$number_of_reviews, na.rm = TRUE)
gradientZH <- colorRampPalette(c("blue", "lightblue"))
gradientBCN <- colorRampPalette(c("red", "pink"))
par(mfrow = c(1, 2))
barplot(table(Barcelona$room_type),
main = "Barcelona",
xlab = "Room Type",
ylab = "Frequency",
col = gradientBCN(4))
barplot(table(Zurich$room_type),
main = "Zurich",
xlab = "Room Type",
ylab = "Frequency",
col = gradientZH(4))
par(mfrow = c(2, 1))
# BARCELONA
# Extract unique levels of neighbourhood_group
unique_neighbourhoods <- unique(Barcelona$neighbourhood_group)
# Use the color palette for each neighbourhood group
boxplot(Barcelona$price ~ Barcelona$neighbourhood_group,
outline = FALSE,
main = "Barcelona - Price per Neighbourhood",
xlab = "Neighbourhood group",
ylab = "Euro",
col = gradientBCN(length(unique_neighbourhoods)))
# ZURICH
# Extract unique levels of neighbourhood_group
unique_neighbourhoods <- unique(Zurich$neighbourhood_group)
# Use the color palette for each neighbourhood group
boxplot(Zurich$price ~ Zurich$neighbourhood_group,  # Corrected: Use Zurich data
outline = FALSE,
main = "Zurich - Price per Neighbourhood",
xlab = "Neighbourhood group",
ylab = "CHF",
col = gradientZH(length(unique_neighbourhoods)))
###############################################################################
# SCATTERPLOT: Price per Availability
plot(Barcelona$availability_365,
Barcelona$price,
col = "darkgrey",
xlim = c(0, 365),
ylim = c(0, 2000),
pch = 16,
cex = 0.4,
main = "Price per availability",
xlab = "Availability in days",
ylab = "Price in euros")
plot(Barcelona$availability_365,
Barcelona$price,
col = "darkgrey",
xlim = c(0, 365),
ylim = c(0, 12000),
pch = 16,
cex = 0.4,
main = "Price per availability",
xlab = "Availability in days",
ylab = "Price in euros")
# SCATTERPLOT: Price per Neighbourhood Group
ggplot(Barcelona, aes(x = neighbourhood_group, y = price)) +
geom_violin() +
geom_jitter(width = 0.2, alpha = 0.25) +
scale_y_log10() +
labs(title = "Neighbourhood vs Price",
subtitle = "Barcelona",
x = "Neighbourhood",
y = "Price") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# STACKED HISTOGRAM: Room Type per Neighbourhood
ggplot(Barcelona, aes(x = neighbourhood_group, fill = room_type)) +
geom_histogram(stat = "count", position = "stack") +
labs(title = "Room Type per Neighbourhood",
subtitle = "Barcelona",
x = "Neighbourhood",
y = "Frequency") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
################################################################################
df_separated <- Barcelona %>%
separate(name,
into = paste("name_part", 1:10, sep = "_"),
sep = " ",
extra = "merge")
head(df_separated)
