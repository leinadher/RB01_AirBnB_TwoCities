dataframe <- data$result$records[c("Nom_Districte", "Nom_Barri", "Valor")]
# Viewing the first few rows of the dataframe
head(dataframe)
# API endpoint
api_url <- "https://opendata-ajuntament.barcelona.cat/data/api/action/datastore_search?resource_id=d0e4ec78-e274-4300-a3bc-cb85cf79014d&limit=3000"
# Sending a GET request to the API and check for success
response <- GET(api_url) %>% stop_for_status()
# Extracting content from the response
data <- fromJSON(content(response, "text"), flatten = TRUE)
# The actual data is usually in a specific part of the JSON
# Adjust the following line according to the structure of the JSON response
demographics <- data$result$records[c("Nom_Districte", "Nom_Barri", "Valor")]
# Viewing the first few rows of the dataframe
head(demographics)
# Processing demographic data: Group by neighborhood and sum values
demographics_grouped <- demographics %>%
group_by(Nom_Barri) %>%
summarise(Total_Population = sum(Valor))
print(demographics)
# Group by neighborhood, convert 'Valor' to numeric, and sum values
demographics_grouped <- demographics %>%
group_by(Nom_Barri) %>%
mutate(Valor = as.numeric(Valor)) %>%  # Convert 'Valor' column to numeric
summarise(Total_Population = sum(Valor))
# Merge the datasets
merged_data <- left_join(Barcelona, demographics_grouped, by =
c("neighbourhood" = "Nom_Barri"))
print(demographics_grouped)
print(n = 73)
print(demographics_grouped, n = 73)
setwd("~/GitHub/RB01_AirBnB_TwoCities")
library(ggplot2)
library(ggthemes)
library(tidyr)
library(dplyr)
library(plotly)
library(RColorBrewer)
library(httr)
library(jsonlite)
theme_minimal() # So that all plots are aesthetically same
# Loading 'listings.csv' files from all city folders:
file_paths <- list.files(pattern = "listings.csv$",
recursive = TRUE,
full.names = TRUE)
for (file_path in file_paths) {
# Extract city name from the file path
city_name <- sub(".*/(\\w+)/listings.csv", "\\1", file_path, perl = TRUE)
# Read CSV file and assign it to a variable with the city name
assign(city_name, read.csv(file_path))
}
################################################################################
# API CALL AND DATA MERGE
# 1. We obtain demographics data (2023_pad_mdbas_sexe.csv) via API
# 2. We merge listings.csv with demographics data
# API endpoint
api_url <- "https://opendata-ajuntament.barcelona.cat/data/api/action/datastore_search?resource_id=d0e4ec78-e274-4300-a3bc-cb85cf79014d&limit=3000"
# Sending a GET request to the API and check for success
response <- GET(api_url) %>% stop_for_status()
# Extracting content from the response
data <- fromJSON(content(response, "text"), flatten = TRUE)
# The actual data is usually in a specific part of the JSON
# Adjust the following line according to the structure of the JSON response
demographics <- data$result$records[c("Nom_Districte", "Nom_Barri", "Valor")]
# Viewing the first few rows of the dataframe
head(demographics)
# Group by neighborhood, convert 'Valor' to numeric, and sum values
demographics_grouped <- demographics %>%
group_by(Nom_Barri) %>%
mutate(Valor = as.numeric(Valor)) %>%  # Convert 'Valor' column to numeric
summarise(Total_Population = sum(Valor))
# Merge the datasets
merged_data <- left_join(Barcelona, demographics_grouped, by =
c("neighbourhood" = "Nom_Barri"))
head(merged_data)
# Summarize the data to count the number of each property type
property_counts <- Barcelona %>%
group_by(room_type) %>%
summarise(quantity = n())
# Create the bar plot
ggplot(property_counts,
aes(x = reorder(room_type, quantity),
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
labs(x = "Room Type",
y = "Frequency",
title = "Frequency of each room type",
subtitle = "Barcelona") +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
# Merge the datasets
Barcelona_md <- left_join(Barcelona, demographics_grouped, by =
c("neighbourhood" = "Nom_Barri"))
head(Barcelona_md)
# Summarize the data to count the number of each property type
property_counts <- Barcelona_md %>%
group_by(room_type) %>%
summarise(quantity = n())
# Create the bar plot
ggplot(property_counts,
aes(x = reorder(room_type, quantity),
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
labs(x = "Room Type",
y = "Frequency",
title = "Frequency of each room type",
subtitle = "Barcelona") +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
# Summarize the data to count the number of each property type
property_counts <- Barcelona_md %>%
group_by(room_type) %>%
summarise(quantity = n())
# Create the bar plot
ggplot(property_counts,
aes(x = reorder(room_type, quantity),
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
labs(x = "Room Type",
y = "Frequency",
title = "Frequency of each room type",
subtitle = "Barcelona") +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
ggplot(Barcelona, aes(x = neighbourhood_group, y = price)) +
geom_jitter(width = 0.2,
alpha = 0.25) +
geom_violin(fill = NA) +
scale_y_log10() +
labs(title = "Neighbourhood vs Price",
subtitle = "Barcelona",
x = "Neighbourhood",
y = "Price") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45,
hjust = 1))
ggplot(Barcelona, aes(x = neighbourhood_group, fill = room_type)) +
geom_histogram(stat = "count", position = "stack") +
labs(title = "Room Type per Neighbourhood",
subtitle = "Barcelona",
x = "Neighbourhood",
y = "Frequency") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
df_separated <- Barcelona %>%
separate(name,
into = paste("name_part", 1:10, sep = "_"),
sep = " ",
extra = "merge")
head(df_separated)
install.packages("stringr")
install.packages("stringr")
library(jsonlite)
library(stringr)
# Define a function to extract star rating
extract_star_rating <- function(name) {
matches <- str_extract(name, "★[0-9]+\\.[0-9]+|[0-9]+")
as.numeric(gsub("★", "", matches))
}
# Apply the function to the 'name' column
Barcelona_md$star_rating <- sapply(Barcelona_md$name, extract_star_rating)
# Display the first five rows of the modified dataframe
head(Barcelona_md[c("name", "star_rating")], 5)
# Display the first five rows of the modified dataframe
head(Barcelona_md[c("name", "star_rating")], 5)
# Define a function to extract star rating
extract_star_rating <- function(name) {
matches <- str_extract(name, "★[0-9]+\\.[0-9]+|[0-9]+")
as.numeric(gsub("★", "", matches))
}
# Apply the function to the 'name' column
Barcelona_md$star_rating <- sapply(Barcelona_md$name, extract_star_rating)
# Display the first five rows of the modified dataframe
head(Barcelona_md[c("name", "star_rating")], 5)
# Display the first five rows of the modified dataframe
head(Barcelona_md[c("name", "star_rating")], 25)
print(Barcelona_md[c("name", "star_rating")])
print(Barcelona_md[c("name", "star_rating")])
plot(Barcelona_md$star_rating, Barcelona_md$price)
Barcelona_md[1]
Barcelona_md$star_rating
view(Barcelona_md)
View(response)
View(Barcelona_md)
View(Barcelona_md)
summary(Barcelona_md)
matches <- str_extract(name, "★([0-9.]+)")
# Define a function to extract star rating
extract_star_rating <- function(name) {
matches <- str_extract(name, "★([0-9.]+)")
as.numeric(gsub("★", "", matches))
}
# Apply the function to the 'name' column
Barcelona_md$star_rating <- sapply(Barcelona_md$name, extract_star_rating)
# Display the first five rows of the modified dataframe
head(Barcelona_md[c("name", "star_rating")], 25)
plot(Barcelona_md$star_rating, Barcelona_md$price)
plot(Barcelona_md$star_rating, Barcelona_md$price, ylim = 12000)
plot(Barcelona_md$star_rating, Barcelona_md$price, ylim = 1200)
# 31.01.2024
setwd("~/GitHub/RB01_AirBnB_TwoCities")
library(ggplot2)
library(ggthemes)
library(tidyr)
library(dplyr)
library(plotly)
library(RColorBrewer)
library(httr)
library(jsonlite)
library(stringr)
theme_minimal() # So that all plots are aesthetically same
################################################################################
# LOADING CITY AIRBNB DATA
# Read listings.csv files from folder with city name, and sabe as data frame
# Loading 'listings.csv' files from all city folders:
file_paths <- list.files(pattern = "listings.csv$",
recursive = TRUE,
full.names = TRUE)
for (file_path in file_paths) {
# Extract city name from the file path
city_name <- sub(".*/(\\w+)/listings.csv", "\\1", file_path, perl = TRUE)
# Read CSV file and assign it to a variable with the city name
assign(city_name, read.csv(file_path))
}
################################################################################
# API CALL AND DATA MERGE
# 1. We obtain demographics data (2023_pad_mdbas_sexe.csv) via API
# 2. We merge listings.csv with demographics data
# API endpoint
api_url <- "https://opendata-ajuntament.barcelona.cat/data/api/action/datastore_search?resource_id=d0e4ec78-e274-4300-a3bc-cb85cf79014d&limit=3000"
# Sending a GET request to the API and check for success
response <- GET(api_url) %>% stop_for_status()
# Extracting content from the response
data <- fromJSON(content(response, "text"), flatten = TRUE)
# The actual data is usually in a specific part of the JSON
# Adjust the following line according to the structure of the JSON response
demographics <- data$result$records[c("Nom_Districte", "Nom_Barri", "Valor")]
# Viewing the first few rows of the dataframe
head(demographics)
# Group by neighborhood, convert 'Valor' to numeric, and sum values
demographics_grouped <- demographics %>%
group_by(Nom_Barri) %>%
mutate(Valor = as.numeric(Valor)) %>%  # Convert 'Valor' column to numeric
summarise(Total_Population = sum(Valor))
# Merge the datasets
Barcelona_md <- left_join(Barcelona, demographics_grouped, by =
c("neighbourhood" = "Nom_Barri"))
################################################################################
# Install and load necessary packages
# Assuming your data is in a dataframe called 'data'
# Read the data (if not already loaded)
# data <- read.xlsx("path_to_your_excel_file.xlsx", sheet = 1)
# Define a function to extract star rating
extract_star_rating <- function(name) {
matches <- str_extract(name, "★([0-9.]+)")
as.numeric(gsub("★", "", matches))
}
# Apply the function to the 'name' column
Barcelona_md$star_rating <- sapply(Barcelona_md$name, extract_star_rating)
# Display the first five rows of the modified dataframe
head(Barcelona_md[c("name", "star_rating")], 25)
View(Barcelona_md)
install.packages("corrplot")
library(corrplot)
# Exclude specific columns
data_selected <- Barcelona_md[, !names(Barcelona_md) %in% c('id',
'latitude',
'longitude',
'number_of_reviews_ltm')]
# Select only numerical columns
numerical_data <- data_selected[sapply(data_selected, is.numeric)]
# Calculate the correlation matrix
corr_matrix <- cor(numerical_data, use = "complete.obs")
# Plot the correlation matrix
corrplot(corr_matrix, method = "color", type = "upper", tl.col = "black", tl.srt = 45)
theme_minimal() # So that all plots are aesthetically same
# Plot the correlation matrix
corrplot(corr_matrix, method = "color", type = "upper", tl.col = "black", tl.srt = 45)
# Plot the correlation matrix
corrplot(corr_matrix, method = "color",
type = "upper",
tl.srt = 45)
tl.col = "black",
# Plot the correlation matrix
corrplot(corr_matrix, method = "color",
type = "upper",
tl.col = "black",
tl.srt = 45)
# Create a color palette that ranges from red to white to blue
col <- colorRampPalette(c("#BB0000", "#FFFFFF", "#0000BB"))(200)
# Plot the correlation matrix with the specified color palette
corrplot(corr_matrix, method = "square", col = col, type = "full", order = "hclust",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
title = "Correlation Heatmap of Numeric Variables", cl.lim = c(-1, 1))
# Plot the correlation matrix with the specified color palette
corrplot(corr_matrix, method = "square", col = col, type = "full", order = "hclust",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
title = "Correlation Heatmap of Numeric Variables", cl.lim = c(-1, 1))
# Plot the correlation matrix
corrplot(corr_matrix, method = "color",
type = "upper",
method = "square",
tl.col = "black",
tl.srt = 45)
# Plot the correlation matrix
corrplot(corr_matrix, method = "color",
type = "upper",
method = "square",
tl.col = "black",
tl.srt = 45)
# Create a color palette that ranges from red to white to blue
col <- colorRampPalette(c("#BB0000", "#FFFFFF", "#0000BB"))(200)
# Plot the correlation matrix with the specified color palette
corrplot(corr_matrix, method = "square", col = col, type = "full", order = "hclust",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
title = "Correlation Heatmap of Numeric Variables", cl.lim = c(-1, 1))
# Plot the correlation matrix with the specified color palette
corrplot(corr_matrix, col = col, type = "full", order = "hclust",
tl.col = "black", tl.srt = 45, addCoef.col = "black",
title = "Correlation Heatmap of Numeric Variables", cl.lim = c(-1, 1))
# Viewing the first few rows of the dataframe
head(demographics)
# Exclude specific columns
numeric_data <- Barcelona_md[, sapply(Barcelona_md, is.numeric)]
numeric_data <- numeric_data[, !colnames(numeric_data) %in% c('id',
'latitude',
'longitude',
'number_of_reviews_ltm')]
corr_matrix <- cor(numeric_data, use = "complete.obs")
corrplot(corr_matrix,
method = "color",
col = colorRampPalette(c("#3C5A99", "#FFFFFF", "#B2182B"))(200))
cor_matrix <- cor(numerical_data)
corrplot(cor_matrix, method = "color", col = viridis::viridis(200), type = "full")
corrplot(cor_matrix, method = "color", col = "blue", type = "full")
corrplot(cor_matrix, method = "color", col = viridis::viridis(200), type = "full")
corrplot(cor_matrix, method = "color", col = col_palette, type = "full")
col_palette <- colorRampPalette(c("#3C5A99", "#FFFFFF", "#B2182B"))(200)
cor_matrix <- cor(numerical_data)
corrplot(cor_matrix, method = "color", col = col_palette, type = "full")
col_palette <- colorRampPalette(c("#3C5A99", "#FFFFFF", "#B2182B"))(200)
corr_matrix <- cor(numeric_data, use = "complete.obs")
corrplot(cor_matrix, method = "color", col = col_palette, type = "full")
# Exclude specific columns
numeric_data <- Barcelona_md[, sapply(Barcelona_md, is.numeric)]
numeric_data <- numeric_data[, !colnames(numeric_data) %in% c('id',
'latitude',
'longitude',
'number_of_reviews_ltm')]
col_palette <- colorRampPalette(c("#3C5A99", "#FFFFFF", "#B2182B"))(200)
corr_matrix <- cor(numeric_data, use = "complete.obs")
corrplot(cor_matrix, method = "color", col = col_palette, type = "full")
corrplot(cor_matrix,
method = "color",
col = col_palette,
tl.col = "black",
tl.srt = 45,
addCoef.col = "black",
type = "full")
# Exclude specific columns
numeric_data <- Barcelona_md[, sapply(Barcelona_md, is.numeric)]
col_palette <- colorRampPalette(c("#3C5A99", "#FFFFFF", "#B2182B"))(200)
corr_matrix <- cor(numeric_data, use = "complete.obs")
corrplot(cor_matrix,
method = "color",
col = col_palette,
tl.col = "black",
tl.srt = 45,
addCoef.col = "black",
type = "full")
cor_matrix <- cor(Barcelona_md)
numeric_data <- Barcelona_md[, sapply(Barcelona_md, is.numeric)]
numeric_data <- numeric_data[, !colnames(numeric_data) %in% c('id', 'latitude', 'longitude', 'number_of_reviews_ltm')]
cor_matrix <- cor(Barcelona_md)
# Melt the correlation matrix to long format
melted_cor_matrix <- melt(cor_matrix)
cor_matrix <- cor(numeric_data)
# Melt the correlation matrix to long format
melted_cor_matrix <- melt(cor_matrix)
library(corrplot)
# Melt the correlation matrix to long format
melted_cor_matrix <- melt(cor_matrix)
cor_matrix <- cor(numeric_data)
cor_matrix
library(reshape2)
install.packages("reshape2")
library(reshape2)
# Melt the correlation matrix to long format
melted_cor_matrix <- melt(cor_matrix)
# Create the heatmap
ggplot(data = melted_cor_matrix, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "blue", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab", name="Pearson\nCorrelation") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, vjust = 1, size = 12, hjust = 1),
axis.text.y = element_text(size = 12),
axis.title = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
legend.title.align = 0.5) +
coord_fixed()
corrplot(numeric_data)
corrplot(cor_matrix)
## Several arguments (with and without defaults)
my.plot <- function(N = 100, my.col = "blue"){
sim.data <- runif(n = N)
x <- 1:N
plot(sim.data ~ x, col = my.col)
}
my.plot(N = 20, my.col = "green")
my.plot(my.col = "red")
my.plot()
my.plot(my.col = "green", main = "Some sim data")
## The "..." argument
my.plot_2 <- function(N = 100, my.col = "blue", ...){
sim.data <- runif(n = N)
x <- 1:N
plot(sim.data ~ x, col = my.col, ...)
}
my.plot_2(my.col = "green", main = "Some simulated data")
###############################
###############################
## for-loops ##
library(stringr)
my.vec <- c("home", "an apple for my elementary teacher", "elicopter")
## You really need to print the object to see the output
## inside a for loop
for (element in my.vec) {
print(paste0("The element is: ", element))
str_extract(element, pattern = "el.")
}
for (element in my.vec) {
print(paste0("The element is: ", element))
tmp <- str_extract(element, pattern = "el.")
print(paste0("The match is: ", tmp))
}
## Create a matrix with random numbers from 0 to 1
m.runif <- matrix(runif(8), nrow = 2, ncol = 4)
m.runif
## sum all elements by row
apply(m.runif, MARGIN = 1, sum)
## sum all elements by column
apply(m.runif, MARGIN = 2, sum)
## Divide each element of the matrix by 2
## MARGIN = c(1, 2) is used to iterate through every element of the matrix
apply(matrix(1:9, ncol = 3), MARGIN = c(1, 2), FUN = function(x){x / 2})
###############################
###############################
## if - else statement ##
set.seed(2024)
a <- runif(1)
a
if (a < 0.5) {
print(paste(a, "is smaller than 0.5"))
} else if ( a > 0.5) {
print(paste(a, "is greater than 0.5"))
} else {
print(a, "is equal to 0.5")
}
# Use ifelse inside a function
my.generator <- function(){
a <- runif(1)
print(paste("The generated value is", a))
if (a < 0.5) {
print("which is smaller than 0.5")
} else if ( a > 0.5) {
print("which is greater than 0.5")
} else {
print("which is equal to 0.5")
}
}
my.generator()
## Put the function in a for-loop
for (i in 1:10) {
my.generator()
}
library(ggplot2)
## Function with all the things we learned today
my.dist <- function(dist, nsim = 1000,
lambda = 1,
size = 100,
prob = 0.5,
min = 0,
max = 1){
possible.distr <- c("poisson", "uniform", "binomial")
if (dist == "poisson") {
my.vec <- rpois(n = nsim, lambda = lambda)
} else if (dist == "uniform") {
my.vec <- runif(n = nsim, min = min, max = max)
} else if (dist == "binomial") {
my.vec <- rbinom(n = nsim, size = size, prob = prob)
} else {
print(paste("Please choose one of the following distributions: ",
paste(possible.distr, collapse = ", " )))
}
d.my.vec <- as.data.frame(my.vec)
ggplot(d.my.vec, mapping = aes(x = my.vec)) +
geom_density()
}
my.dist
my.dist()
seq_along(1:5)
seq_along(c(1,2,3,4,5))
seq_along(c(1,24))
runif(1, 4, 6)
runif(5, 1, 10)
plot(runif(10, 1, 10), seq(1,10))
plot(runif(10, 1, 10) ~ seq(1,10))
