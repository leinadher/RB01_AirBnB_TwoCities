geojson_BCN
dim(geojson_BCN)
merged_data
geojson_BCN <- sf::st_read("Data/Barcelona/neighbourhoods.geojson")
setwd("~/GitHub/RB01_AirBnB_TwoCities")
geojson_BCN <- sf::st_read("Data/Barcelona/neighbourhoods.geojson")
merged_data <- merge(geojson_BCN,
Barcelona_md,
by = "neighbourhood",
all.x = TRUE)
geojson_BCN
# Extracting longitude and latitude from geometry
geojson_BCN_coords <- st_coordinates(geojson_BCN)
geojson_BCN$lon <- geojson_BCN_coords[, "X"]
# Extracting longitude and latitude from geometry
geojson_BCN_coords <- st_coordinates(geojson_BCN)
geojson_BCN_coords
# Extracting longitude and latitude from geometry
geojson_BCN_coords <- st_coordinates(geojson_BCN)
geojson_BCN$lon <- geojson_BCN_coords[, "X"]
# Extracting longitude and latitude from geometry
geojson_BCN_coords <- st_coordinates(geojson_BCN)
geojson_BCN$lon <- geojson_BCN_coords[, "X"]
# Extracting centroid coordinates from geometry
geojson_BCN_centroids <- st_centroid(geojson_BCN)
# Check and fix geometries
geojson_BCN <- st_make_valid(geojson_BCN)
# Extracting centroid coordinates from geometry
geojson_BCN_centroids <- st_centroid(geojson_BCN)
# Check for invalid geometries
invalid_geometries <- st_is_valid(geojson_BCN)
# Identify which features have invalid geometries
invalid_indices <- which(!invalid_geometries)
# Print information about invalid geometries
print(geojson_BCN[invalid_indices, ])
# Attempt to fix geometries with a small buffer
geojson_BCN_buffered <- st_buffer(geojson_BCN, dist = 0.000001)
# Attempt to fix geometries with a small buffer
geojson_BCN_buffered <- st_buffer(geojson_BCN, dist = 0.000001)
# Extracting centroid coordinates from geometry
geojson_BCN_centroids <- st_centroid(geojson_BCN)
geojson_BCN_centroids <- st_point_on_surface(geojson_BCN)
geojson_BCN$lon <- st_coordinates(geojson_BCN_centroids)[, "X"]
geojson_BCN$lat <- st_coordinates(geojson_BCN_centroids)[, "Y"]
library(ggrepel)
install.packages(ggrepel)
install.packages(ggrepel)
install.packages(ggrepel)
install.packages("ggrepel")
library(ggrepel)
library(ggplot2)
library(ggrepel)
library(ggrepel)
geom_sf_text_repel
#c77cff
knitr::opts_chunk$set(echo = TRUE)
setwd("~/GitHub/RB01_AirBnB_TwoCities")
library(ggplot2)
library(ggthemes)
library(tidyr)
library(dplyr)
library(plotly)
library(RColorBrewer)
library(httr)
library(jsonlite)
library(stringr)
library(corrplot)
library(reshape2)
library(readxl)
library(gridExtra)
library(stringr)    ## to modify strings
# For maps:
library(sf)
library(ggmap)
library(leaflet)
library(osmdata)
library(maptiles)   ## for get_tiles() / used instead of OpenStreetMap
library(tidyterra)  ## for geom_spatraster_rgb() - Background tiles
library(ggrepel)    ## to plot labels which don't overlap
# Set default graphics device to PDF
options(knitr.graphics.format = "svg")
################################################################################
# LOADING CITY AIRBNB DATA
# Read listings.csv files from folder with city name, and save as data frame
# Loading 'listings.csv' files from all city folders:
file_paths <- list.files(pattern = "listings.csv$",
recursive = TRUE,
full.names = TRUE)
for (file_path in file_paths) {
# Extract city name from the file path
city_name <- sub(".*/(\\w+)/listings.csv", "\\1", file_path, perl = TRUE)
# Read CSV file and assign it to a variable with the city name
assign(city_name, read.csv(file_path))
}
################################################################################
dim(Barcelona)
str(Barcelona)
################################################################################
# API CALL AND DATA MERGE
# 1. We obtain demographics data (2023_pad_mdbas_sexe.csv) via API
# 2. We merge listings.csv with demographics data
# API endpoint
api_url <- "https://opendata-ajuntament.barcelona.cat/data/api/action/datastore_search?resource_id=d0e4ec78-e274-4300-a3bc-cb85cf79014d&limit=3000"
# Sending a GET request to the API and check for success
response <- GET(api_url) %>% stop_for_status()
# Extracting content from the response
data <- fromJSON(content(response, "text"), flatten = TRUE)
# The actual data is usually in a specific part of the JSON
# Adjust the following line according to the structure of the JSON response
demographics <- data$result$records[c("Nom_Districte", "Nom_Barri", "Valor")]
# Viewing the first few rows of the dataframe
head(demographics)
# Group by neighborhood, convert 'Valor' to numeric, and sum values
demographics_grouped <- demographics %>%
group_by(Nom_Barri) %>%
mutate(Valor = as.numeric(Valor)) %>%  # Convert 'Valor' column to numeric
summarise(Total_Population = sum(Valor))
# Merge the datasets
Barcelona_md <- left_join(Barcelona, demographics_grouped, by =
c("neighbourhood" = "Nom_Barri"))
################################################################################
# EXTRACT STAR-RATING FROM NAME, AND ADD AS COLUMN TO DATA FRAME
extract_star_rating <- function(name) {
matches <- str_extract(name, "★([0-9.]+)")
as.numeric(gsub("★", "", matches))
}
Barcelona_md$star_rating <- sapply(Barcelona_md$name, extract_star_rating)
head(Barcelona_md[c("name", "star_rating")], 5)
################################################################################
# EXTRACT LICENSE STATUS
# Save to a new column 'LicenseGrouping'
Barcelona_md <- Barcelona_md %>%
mutate(LicenseGrouping = case_when(
grepl("Exempt", license, ignore.case = TRUE) ~ "Exempt",
license != "" & !is.na(license) ~ "License is displayed",
TRUE ~ "License is not displayed"
))
print(Barcelona_md)
################################################################################
# GROUP LARGE TENANTS AND SMALL TENANTS
Barcelona_md <- Barcelona_md %>%
mutate(TenantSizeGrouping = case_when(
calculated_host_listings_count >= 5 ~ "Large tenant",
calculated_host_listings_count <= 4 ~ "Small tenant",
TRUE ~ NA_character_ # This handles any unexpected cases, such as missing values
))
# View the first few rows of the transformed dataset to verify the changes
head(Barcelona_md)
################################################################################
# HOST COUNT: LARGE TENANTS AND SMALL TENANTS
# Create a new data frame named tenants
tenants <- Barcelona_md %>%
group_by(host_id) %>%
summarise(listing_count = n())
tenants <- tenants %>%
mutate(TenantSizeGrouping = case_when(
listing_count >= 5 ~ "Large tenant",
listing_count <= 4 ~ "Small tenant",
TRUE ~ NA_character_ # This handles any unexpected cases, such as missing values
))
################################################################################
# FILTER OUT WRONG OUTLIERS
# Specifically, a listing valued at about €60,000 per night,
# which is missing other information fields, and distorts further plots.
# This was a team-agreed decision to provide cleaner results.
Barcelona_md <- filter(Barcelona_md, is.na(price) | price < 50000)
################################################################################
# Load API key. UPDATE WHEN EXPIRED!
register_stadiamaps("8df95c0b-0133-4440-b3f0-c1c6e2f26844", write = TRUE)
# Load GeoJSON file and convert to sf object, merg it with Barcelona_md
geojson_BCN <- sf::st_read("Data/Barcelona/neighbourhoods.geojson")
merged_data <- merge(geojson_BCN,
Barcelona_md,
by = "neighbourhood",
all.x = TRUE)
# Create bounding box limits, map and merge geojson with Barcelona_md
bbox.limits <- sf::st_bbox(geojson_BCN)
map_BCN <- get_stadiamap(getbb("Barcelona"), maptype = "stamen_toner_lite", zoom = 13)
# Plot map
ggmap(map_BCN) +
geom_sf(data = merged_data,
inherit.aes = FALSE,
aes(fill = price.y, label = neighbourhood),
fill = "white",
alpha = 0,
color = "#f1796f",
linewidth = 0.5) +
geom_point(data = Barcelona_md,
aes(x = longitude, y = latitude),
color = "#f1796f",
alpha = 0.2,
size = 0.4) +
labs(title = "Airbnb listings overview",
subtitle = "Barcelona",
x = "Longitude",
y = "Latitude")
listings_count <- Barcelona_md %>%
group_by(neighbourhood_group) %>%
summarise(number_of_listings = n()) %>%
arrange(number_of_listings)  # Ascending order
ggplot(listings_count, aes(x = reorder(neighbourhood_group,
number_of_listings),
y = number_of_listings,
fill = neighbourhood_group)) +
geom_bar(stat = "identity",
color = NA,
show.legend = FALSE) +
scale_fill_manual(values = rep("#f1796f",
length(unique(listings_count$neighbourhood_group)))) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45,
hjust = 1)) +
labs(x = "Neihgbourhood group",
y = "",
title = "Airbnb listings by neighbourhood group",
subtitle = "Barcelona") +
scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
scale_y_continuous(breaks = seq(0, max(listings_count$number_of_listings), by = 1000))
# Group by neighbourhood and count
data_grouped <- Barcelona_md %>%
group_by(neighbourhood_group) %>%
summarise(count = n())
# Group total population by neighbourhood group
unique_population_per_neighbourhood_group <- Barcelona_md %>%
select(neighbourhood_group, Total_Population) %>%
distinct() %>%
filter(!is.na(Total_Population)) %>%
group_by(neighbourhood_group) %>%
summarise(Total_Population = sum(Total_Population))
data_grouped_with_population <- left_join(data_grouped,
unique_population_per_neighbourhood_group,
by = "neighbourhood_group")
data_grouped_with_population$proportion <- data_grouped_with_population$count / data_grouped_with_population$Total_Population
data_grouped_with_population$proportion_percent <- data_grouped_with_population$proportion * 100
# Barplot in ggplot2 as percentages
ggplot(data_grouped_with_population, aes(x = reorder(neighbourhood_group, proportion_percent), y = proportion_percent)) +
geom_bar(stat = "identity", fill = "#f1796f") +
theme_minimal() +
labs(title = "Airbnb listings per 100 residents by neighbourhood group",
subtitle = "Barcelona",
x = "Neighbourhood group",
y = "Percentage (%)") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Summarize the data to count the number of each property type
property_counts <- Barcelona_md %>%
group_by(room_type) %>%
summarise(quantity = n())
# Create the bar plot
ggplot(property_counts,
aes(x = reorder(room_type, quantity),
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
geom_text(aes(label = quantity),
hjust = 0,
size = 3) +
labs(x = "",
y = "",
title = "Room type count",
subtitle = "Barcelona") +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE) +  # Remove the legend
theme_minimal()
ggplot(Barcelona_md, aes(x = neighbourhood_group)) +
geom_bar(aes(fill = room_type), position = "dodge") +
facet_wrap(~ room_type, scales = "free_y", nrow = 2) +
theme_minimal() +
labs(title = "Acommodation type by neighbourhood group",
subtitle = "Barcelona",
x = "Neighbourhood group",
y = "Count") +
theme_minimal() +
theme(axis.text.x = element_text(size = 8, angle = 45, hjust = 1))
license_count <- Barcelona_md %>%
group_by(LicenseGrouping) %>%
summarise(quantity = n())
# Create the bar plot
ggplot(license_count,
aes(x = reorder(LicenseGrouping, quantity),
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
labs(x = "",
y = "Count",
title = "License status",
subtitle = "Barcelona") +
geom_text(aes(label = quantity),
hjust = 0,
size = 3) +
theme_minimal() +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
license_count <- Barcelona_md %>%
group_by(LicenseGrouping) %>%
summarise(quantity = n())
# Create the bar plot
ggplot(license_count,
aes(x = reorder(LicenseGrouping, quantity),
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
labs(x = "",
y = "",
title = "License status",
subtitle = "Barcelona") +
geom_text(aes(label = quantity),
hjust = 0,
size = 3) +
theme_minimal() +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
tenant_count <- tenants %>%
group_by(TenantSizeGrouping) %>%
summarise(listing_count = n())
# Host numbers: great vs. small tenants
plotA <- ggplot(tenant_count,
aes(x = TenantSizeGrouping,
y = listing_count,
fill = "red")) +
geom_bar(stat = "identity") +
labs(x = "",
y = "Host count",
title = "Large vs. small tenants - Host count",
subtitle = "Barcelona") +
geom_text(aes(label = listing_count),
hjust = 0,
size = 3) +
theme_minimal() +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
# Listing numbers: great vs. small tenants
tenant_count <- Barcelona_md %>%
group_by(TenantSizeGrouping) %>%
summarise(quantity = n())
plotB <- ggplot(tenant_count,
aes(x = TenantSizeGrouping,
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
labs(x = "",
y = "Listing Count",
title = "Large vs. small tenants - Listing count",
subtitle = "Barcelona") +
geom_text(aes(label = quantity),
hjust = 0,
size = 3) +
theme_minimal() +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
grid.arrange(plotA, plotB, ncol = 1)
tenant_count <- tenants %>%
group_by(TenantSizeGrouping) %>%
summarise(listing_count = n())
# Host numbers: great vs. small tenants
plotA <- ggplot(tenant_count,
aes(x = TenantSizeGrouping,
y = listing_count,
fill = "red")) +
geom_bar(stat = "identity") +
labs(x = "",
y = "",
title = "Large vs. small tenants - Host count",
subtitle = "Barcelona") +
geom_text(aes(label = listing_count),
hjust = 0,
size = 3) +
theme_minimal() +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
# Listing numbers: great vs. small tenants
tenant_count <- Barcelona_md %>%
group_by(TenantSizeGrouping) %>%
summarise(quantity = n())
plotB <- ggplot(tenant_count,
aes(x = TenantSizeGrouping,
y = quantity,
fill = 'red')) +
geom_bar(stat = "identity") +
labs(x = "",
y = "",
title = "Large vs. small tenants - Listing count",
subtitle = "Barcelona") +
geom_text(aes(label = quantity),
hjust = 0,
size = 3) +
theme_minimal() +
coord_flip() + # Flip the plot to horizontal bars
guides(fill = FALSE)  # Remove the legend
grid.arrange(plotA, plotB, ncol = 1)
listings_per_host <- Barcelona_md %>%
group_by(host_id) %>%
summarize(count = n(), .groups = 'drop') %>%
filter(!is.na(host_id))
# Group all counts of 10 or more into '10+'
listings_per_host$count_grouped <- ifelse(listings_per_host$count > 10,
"10+",
as.character(listings_per_host$count))
# Convert the column to a factor to control the order in the plot
listings_per_host$count_grouped <- factor(listings_per_host$count_grouped,
levels = c(as.character(1:10),
"10+"))
# Create the histogram
ggplot(listings_per_host, aes(x = count_grouped)) +
geom_bar(fill = "#f1796f") +
labs(x = "Listing count",
y = "Number of hosts",
title = "Number of hosts per listing count",
subtitle = "Barcelona") +
theme(axis.text.x = element_text()) +
theme_minimal()
top_hosts <- Barcelona_md %>%
distinct(host_id, .keep_all = TRUE) %>%
arrange(desc(calculated_host_listings_count)) %>%
slice_head(n = 5)
# Create the ggplot2 horizontal barplot
ggplot(top_hosts, aes(x = reorder(host_name, calculated_host_listings_count),
y = calculated_host_listings_count)) +
geom_bar(stat = "identity",
fill = "#f1796f") +
geom_text(aes(label = calculated_host_listings_count),
hjust = 0,
color = "black",
size = 3) +
labs(title = "Top 5 hosts by number of listings",
subtitle = "Barcelona",
x = "",
y = "") +
coord_flip() + # Flip the plot to horizontal bars
theme_minimal() +
theme(axis.text.x = element_text(angle = 0, hjust = 1))
ggplot(Barcelona_md, aes(x = neighbourhood_group, y = price)) +
geom_jitter(width = 0.2,
alpha = 0.25,
color = "#f1796f") +
geom_violin(fill = NA) +
scale_y_log10() +
labs(title = "Price by neighbourhood group",
subtitle = "Barcelona",
x = "Neighbourhood group",
y = "Price (€)") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45))
ggplot(Barcelona_md, aes(x = neighbourhood_group, y = price)) +
geom_boxplot(fill = "#f1796f", alpha = 0.4, outlier.color = "#f1796f", color = "#f1796f") +
scale_y_continuous(trans = "log10",
breaks = c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000),
labels = c("1", "5", "10", "50", "100", "500", "1000", "5000", "10000")) +
labs(title = "Price boxplots by neighbourhood group",
subtitle = "Barcelona",
x = "Neighbourhood group",
y = "Price (€)") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, vjust = 0.7))
# Modify the minimum_nights column to create a '35+' category
Barcelona_md$minimum_nights_grouped <- ifelse(Barcelona_md$minimum_nights > 35,
"35+",
as.character(Barcelona_md$minimum_nights))
# Convert the column to a factor to control the order in the plot
Barcelona_md$minimum_nights_grouped <- factor(Barcelona_md$minimum_nights_grouped,
levels = c(as.character(1:35),
"35+"))
# Create the histogram
ggplot(Barcelona_md, aes(x = minimum_nights_grouped)) +
geom_bar(fill = "#f1796f") +
labs(x = "Minimum nights",
y = "Count",
title = "Listings by minimum nights",
subtitle = "Barcelona") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 0,
vjust = 0.5,
hjust = 1))
ggplot(Barcelona_md, aes(x = neighbourhood_group, y = number_of_reviews)) +
geom_boxplot(fill = "#00bfc4", alpha = 0.4, outlier.color = "#00bfc4", color = "#00bfc4") +
coord_cartesian(ylim = c(0, 200)) +
labs(title = "Reviews boxplots by neighbourhood group",
subtitle = "Barcelona",
x = "Neighbourhood group",
y = "Review count") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, vjust = 0.7))
numeric_data <- Barcelona_md[, sapply(Barcelona_md, is.numeric)]
numeric_data <- numeric_data[, !colnames(numeric_data) %in% c('host_id',
'id',
'latitude',
'longitude',
'number_of_reviews_ltm')]
# Compute correlation matrix
cor_matrix <- cor(numeric_data, use = "pairwise.complete.obs")
# Convert correlation matrix to long format for ggplot
cor_df <- as.data.frame(as.table(cor_matrix))
names(cor_df) <- c("Var1", "Var2", "Correlation")
ggplot(cor_df, aes(Var1, Var2)) +
geom_point(aes(fill = Correlation), size = 12, shape = 21, color = "white") +
scale_size_continuous(guide = "none") +  # Remove size legend
scale_fill_gradient(low = "white", high = "#f1796f") +
labs(title = "Correlation of numerical values",
subtitle = "Barcelona",
x = "",
y = "") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
plot.margin = unit(c(0, 0, 2, 0), "lines"))
ggplot(Barcelona_md, aes(x = star_rating, y = price)) +
geom_point(width = 0.1,
alpha = 0.4) + # Plot the points
geom_smooth(method = "lm", color = "#f1796f") + # Add linear model line
labs(title = "Price by star rating",
subtitle = "Barcelona",
x = "Star rating",
y = "Price (€)") +
theme_minimal()
